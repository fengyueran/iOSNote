#RunLoop

在iOS开发中时常遇到RunLoop的概念，那RunLoop究竟是什么呢？它是与线程相关的一个概念，是多线程相关功能的幕后工程，了解RunLoop对我们认识多线程大有帮助。

在认识runloop之前首先要有这样一个概念：一个线程在执行完一个任务后就会结束，比如在屏幕输出文字，当文字输出后线程就结束了，不能再输出文字了。而事实并非如此，我们点击屏幕系统总是能给出反馈，这说明线程并未结束，即可认为该线程一直在执行任务并未退出，由此我们想到了循环。

####1.什么是RunLoop

```objc
RunLoop实际上就是一个对象，这个对象来管理消息的接收处理，在iOS中提供了两个这样的对象：NSRunLoop和CFRunLoopRef。
CFRunLoopRef是在CoreFoundation框架下的纯C函数的API且是线程安全的。
NSRunLoop是基于CFRunLoopRef的封装，提供了面向对象的API，但不是线程安全的。
RunLoop的基本逻辑：
```objc
function loop() {
    initialize();
    do {
        var message = get_next_message();
        process_message(message);
    } while (message != quit);
}
```
可以看到runloop就是一个不停处理消息的循环，它时刻准备着接收->处理消息，只有当接收到终止消息后才会结束。因此只要不退出这个循环就能一直接收消息并处理，这就达到了线程一直不退出而可以时刻执行任务的目的。这个循环并不一直占用CPU，而是一种闲等待，类似于linux下的epoll，只有接收到事件后才会占用资源，不需要处理事件时休眠，其基本流程如下图(苹果官方流程图)，可以看到RunLoop从输入源接收事件并进行处理。
![](/assets/pic19-1.jpg)


####2.RunLoop与线程的关系
由runloop的逻辑我们知道一个线程要维持其生命就必须有对应的runloop。苹果不允许我们直接创建 RunLoop而只给出了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。
```objc
//全局的Dictionary，key:pthread_t(线程)；value:CFRunLoopRef(runloop)
static CFMutableDictionaryRef __CFRunLoops = NULL;
//访问__CFRunLoops字典的锁
static CFLock_t loopsLock = CFLockInit;


CFRunLoopRef _CFRunLoopGet0(pthread_t t) {
    if (pthread_equal(t, kNilPthreadT)) {
	t = pthread_main_thread_np();
    }
    __CFLock(&loopsLock);
    if (!__CFRunLoops) {
        __CFUnlock(&loopsLock);
	CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &kCFTypeDictionaryValueCallBacks);
	//第一次进入时为主线程创建RunLoop
	CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());
	CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);
	if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&__CFRunLoops)) {
	    CFRelease(dict);
	}
	CFRelease(mainLoop);
        __CFLock(&loopsLock);
    }
    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));
    __CFUnlock(&loopsLock);
    if (!loop) {
        //取不到loop时创建
	CFRunLoopRef newLoop = __CFRunLoopCreate(t);
        __CFLock(&loopsLock);
       //从字典的获取runloop
	loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));
	if (!loop) {
	   //给__CFRunLoops字典赋值
	    CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);
	    loop = newLoop;
	}
        // don't release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it
        __CFUnlock(&loopsLock);
	CFRelease(newLoop);
    }
    if (pthread_equal(t, pthread_self())) {
        _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL);
        if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) {
        //注册一个回调，当线程销毁时销毁对应的runloop
            _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop);
        }
    }
    return loop;
}

CFRunLoopRef CFRunLoopGetMain(void) {
    CHECK_FOR_FORK();
    static CFRunLoopRef __main = NULL; // no retain needed
    if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); // no CAS needed
    return __main;
}

CFRunLoopRef CFRunLoopGetCurrent(void) {
    CHECK_FOR_FORK();
    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);
    if (rl) return rl;
    return _CFRunLoopGet0(pthread_self());
}
```
可以看到线程和runloop是一一对应的关系，存在于一个全局的字典里。当创建线程时并没有runloop直到第一次获取runloop，如果不主动获取线程是没有runloop的，当线程结束时runloop销毁。在通常的iOS项目中UIApplicationMain方法启动了与主线程相关的RunLoop，因此不需要我们手动启动。
```objc
int main(int argc, char * argv[])
{
    @autoreleasepool {
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
}
```

####3.RunLoop的相关类
在CoreFoundation中关于RunLoop类有5个:
```objc
CFRunLoopRef
CFRunLoopModeRef//没有对外暴露而是通过CFRunLoopRef接口进行了封装
CFRunLoopSourceRef
CFRunLoopTimerRef
CFRunLoopObserverRef
```
他们之间关系如下图：

![](/assets/pic19-2.png)
从图中可以看到一个RunLoop由弱干个Mode组成，一个Mode又由Source/Observer/Timer组成。每次进入RunLoop的主函数只能指定一个Mode，即CurrentMode，从而避免不同Mode下的Source/Observer/Timer相互影响。如果想重新切换Mode只能退出当前Mode重新进入新的Mode。
**CFRunLoopSourceRef输入源：**
它是事件产生的地方，主要有两个版本Source0 和 Source1。
Source0：非基于端口port，例如触摸、滚动、selector选择器等用户触发的事件，只包含一个回调，不能主动触发事件，必须先把这个source标记(CFRunLoopSourceSignal(source))为待处理，然后手动调用CFRunLoopWakeUp(runloop) 来唤醒RunLoop，让其处理这个事件。
Source1基于端口port，一些系统事件，包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种Source能主动唤醒RunLoop 的线程。

**CFRunLoopTimerRef定时源：**
不难想象它是基于时间的触发器，包含一个时间长度和回调函数指针，当定时源加入到RunLoop时，RunLoop会注册相应的时间节点，当时间点到时执行那个回调函数。

**CFRunLoopObserverRef观察者：**
它包含了一个回调，当RunLoop状态发生变化时，观察者就能通过回调接收到这个变化，RunLoop的状态有以下几个：
```objc
```
