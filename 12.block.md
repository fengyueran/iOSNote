#Block
初学Block的时候感觉blcok很怪异，又是参数又是代码段的。为了搞清楚block到底是什么，查阅了相关资料做一个总结。

#####1.block的简单使用
block如其名，它封装了一段代码块，并用类似C函数的方式block()进行调用。
- 认识block
如下就是一个block，等号左边声明了一个blcok，这个block的返回值为int，它的名称为
^后的sum，它有两个整型参数a、b。等号右边为block的定义，^后边跟着参数列表，代码块包裹在大括号中。
```
int (^sum)(int a, int b) = ^(int a, int b) {
    return a + b;
};
```



#####1.block是什么
为了搞清楚block先用clang编译器编译(clang -rewrite-objc 一hello.m)个简单的block:
```objc
int main() {
    void (^myBlock)(void) = ^{
        int xh = 0;
    };
    myBlock();
}
```
编译出来100多行，摘取关键信息并给出注释：
```objc
//block结构体
struct __block_impl {
  /*指向对象的isa指针，有三种类型
    //栈类型
    impl.isa = &_NSConcreteStackBlock; 
    //堆类型
    impl.isa = &_NSConcreteMallocBlock;
    //全局类型 
    impl.isa = &_NSConcreteGlobalBlock;
  */
  void *isa;
  //按位承载 block 的附加信息
  int Flags;
  保留变量
  int Reserved;
  函数指针，指向 Block 要执行的函数，即匿名函数{int xh = 0;};
  void *FuncPtr;
};

//block实现的结构体，block初始化入口
struct __main_block_impl_0 {
  //block结构体实例
  struct __block_impl impl;
  //描述结构体变量
  struct __main_block_desc_0* Desc;
  //构造函数，初始化block
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {
    impl.isa = &_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};

//block执行的函数
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
        int xh = 0;
}

//block描述信息结构体
static struct __main_block_desc_0 {
//结构体信息保留字段
  size_t reserved;
  //结构体大小
  size_t Block_size;
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};

int main() {
    void (*myBlock)(void) = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA));
    ((void (*)(__block_impl *))((__block_impl *)myBlock)->FuncPtr)((__block_impl *)myBlock);
}

```
从main方法可以看到block实现的一个基本流程：调用__main_block_impl_0初始化结构体-> 通过__main_block_impl_0给block赋值->执行block的FuncPtr函数。

#####2.block获取外部变量
来看这样一个例子：
```objc
int main() {
    int value = 10;
    void (^myBlock)(void) = ^{
        int xh = value;
    };
    myBlock();
}
```
同样用clang编译，从编译结果可以看到在构造函数__main_block_impl_0调用时通过值传递把value传给了_value并用_value初始化__main_block_impl_0结构体的同名变量value。既然是值传递自然无法在block中修改变量value的值。
```objc
struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  int value;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _value, int flags=0) : value(_value) {
    impl.isa = &_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
//通过self指针拿到结构体成员变量
  int value = __cself->value; // bound by copy
        int xh = value;
}
```
#####3.block内修改外部变量
前面已经提到在block内不能修改外部的局部变量，在OC中有两种类型的变量可以在block内进行修改，包括全局变量，静态变量。如果需要在block内修改block外的局部变量则需要添加__block关键字。__block是什么呢、clang编译以下代码：
```objc
int main() {
    __block int value = 10;
    void (^myBlock)(void) = ^{
        value = 20;
        int xh = value;
    };
    myBlock();
}

```
得到：
```objc
struct __block_impl {
  void *isa;
  int Flags;
  int Reserved;
  void *FuncPtr;
};

//封装__block变量修饰的外部变量的结构体
struct __Block_byref_value_0 {
 //对象指针
 void *__isa;
 //指向自己的指针
 __Block_byref_value_0 *__forwarding;
 //标志位
 int __flags;
 //结构体大小
 int __size;
 //外部变量
 int value;
};


struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  __Block_byref_value_0 *value; // by ref
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_value_0 *_value, int flags=0) : value(_value->__forwarding) {
    impl.isa = &_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};

static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  __Block_byref_value_0 *value = __cself->value; // bound by ref
        (value->__forwarding->value) = 20;
        int xh = (value->__forwarding->value);
    }
    
static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&dst->value, (void*)src->value, 8/*BLOCK_FIELD_IS_BYREF*/);}

static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src->value, 8/*BLOCK_FIELD_IS_BYREF*/);}

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
  void (*dispose)(struct __main_block_impl_0*);
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};

int main() {
    __attribute__((__blocks__(byref))) __Block_byref_value_0 value = {(void*)0,(__Block_byref_value_0 *)&value, 0, sizeof(__Block_byref_value_0), 10};
    void (*myBlock)(void) = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, (__Block_byref_value_0 *)&value, 570425344));
    ((void (*)(__block_impl *))((__block_impl *)myBlock)->FuncPtr)((__block_impl *)myBlock);
}
```
从main函数和初始化函数可以看到__block value编译后的__Block_byref_value_0结构体指针变量通过指针传递给block。

#####4.block的内存管理

