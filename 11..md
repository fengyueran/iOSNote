#循环引用

ARC时代给我们管理内存带来了很大的便利，能够解决绝大多数内存管理问题，但也存在例外，比如循环引用retain cycle。

#####1.什么是循环引用
循环引用指两个对象相互引用对方，造成引用计数加1导致谁也释放不了谁的内存泄漏问题，当然多个对象产生的环也一样。小A说：“小B给老子放手”，“你给老子放手，老子 就放手”，小B说。结果俩都不放手，一直僵持着，就这样他们的故事一直延续着。

![](/assets/pic11-1.png)

#####2.容易出现循环引用的几种场景
1）对象直接相互引用
有个Person类，它有一个strong类型的dog属性；
```objc
#import <Foundation/Foundation.h>
@class Dog;
@interface Person : NSObject
@property (strong, nonatomic) Dog *dog;
@end

@implementation Person
- (void)dealloc {
    NSLog(@"person is dead");
}
@end
```
有个Dog类，它有一个strong类型的master属性；
```objc
#import <Foundation/Foundation.h>

@interface Dog : NSObject
@property(strong, nonatomic) id master;
@end

@implementation Dog
- (void)dealloc {
    NSLog(@"dog is dead");
}
@end
```
如下Person对象xiaoMing引用了Dog对象husky，husky又引用了Person对象xiaoMing，造成了循环引用，程序后二者的dealloc方法都不输出，说明都没有两个对象都没有被释放。
```objc
#import "ViewController.h"
#import "Person.h"
#import "Dog.h"

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    Person *xiaoMing = [[Person alloc]init];
    Dog *husky = [[Dog alloc]init];
    xiaoMing.dog = husky;
    husky.master = xiaoMing;
}

@end

```
解决办法：
主动断链，使用weak属性：
```objc
@interface Person : NSObject
@property (weak, nonatomic) Dog *dog;
@end
```
显然weak属性不会retain对象，所有xiaoMing不会强引用husky，也就不会出现循环引用，程序运行后：
打印出
2017-02-17 14:28:43.792665 1[2884:799213] dog is dead
2017-02-17 14:28:43.792763 1[2884:799213] person is dead